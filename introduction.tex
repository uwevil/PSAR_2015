
\chapter{Introduction}
	{\huge \itshape D}ans ce sujet, on abordera sur les recherches par mots clés. Une fois, on tape un mot ou une chaine de mots, l'application cherche dans la base de données pour trouver la liste des documents qui contient les descriptions correspondantes avec ces mots clés.
	
	Dans la base de données qui contient des grosses masses de donées, les index sont basés sur les descriptions des documents. Chaque mot est une clé, chaque clé contient une liste des documents ayant ce mot. Au contraire à la liste normale, le mot clé est le nom du document et il contient la liste des mots qui se trouvent dans la description de ce document. Par exemple, le mot {\em PSAR : le projet pour les étudiants du M1}, normalement, le mot clé est {\em PSAR}, donc il contient sa description {\em le projet pour les étudiants du M1}, mais dans cette liste, les mots clés sont {\em le, projet, pour, les, étudiants, du, M1} et chaque mot contient le mot {\em PSAR}. On s'appelle la {\em liste inversée}.
	
	Du coup, on utilise les tables de hachage distribuées (DHT) pour stocker les listes inversées. L'avantage d'utilisation de ces tables est que la complexité est égale à $ \theta ${\em (1)} car on trouve directement l'élément que l'on recherche. La statégie de distribution des listes inversées la plus utilisée (appelée partionnement vertical) consiste à associer à chaque terme une clé qui désigne le pair qu stocke la liste inversée associée à ce terme. Une fois que l'on lance la recherche sur les documents qui sont satisfaits à l'ensemble des mots que l'on a saisi, le système doit chercher pour chaque mot dans cet ensemble la liste des documents qui le contiennent, et puis fait l'intersection des listes inversées retrouvées. 

	Dans les systèmes pair-à-pair (P2P), chaque n{\oe}ud contient un ou plusieurs mots clés, une fois qu'on cherche un mot, le système va demander le n{\oe}ud où se trouve ces mots clés. Le problème est que si l'on cherche un ensemble de mots, il doit obligatoirement envoyer plusieurs requêtes à plusieurs n{\oe}uds pour récupérer les listes des documents et les faire l'intersection. Si on a un grand nombre de machines qui cherchent une quantité importante de mots clés, le système sera saturé. Et aussi, le problème se pose sur un ou quelques n{\oe}uds précises, et les autres sont libres dans la plupart de temps. Donc, le coût de la recherche est d'autant plus élevé que la requête est précise et le déséquilibrage de charges des noeuds d'indexation du fait de la non-uniformité de la popularité des termes, ce sont des problèmes qu'on va rechercher la solution dans ce projet.
	
	