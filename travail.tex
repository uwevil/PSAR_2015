\chapter{Réalisation du travail}
\section{Notre solution}
	Nous avons choisi le filtre de Bloom de taille fixe de 512 bits. A partir des descriptions en entrée, ce programme transforme chaque mot clé en 1 bit avec la position précise dans notre filtre. Nous avons utilisé une seul fonction de hachage comme SHA 256 bits, cette fonction encode le mot clé en une chaine hexadécimale de 256 bits. Avec un simple calcul, le filtre est bien rempli. Nous avons choisi seulement une fonction de hachage car si on utilise plus de 2 fonctions, avec un seul mot, elle génère 2 bits différents, donc, si on a 200 mots clés, ce filtre devient être tout rempli par 1. Ce problème nous rend l'imposibité de réduire l'ensemble des données à recherche. Et pourquoi doit-on ne pas augmenter la taille de filtre? Mais quelle taille suffit-il pour 200 descriptions si on a 3 fonctions de hachage? Après plusieurs tests et discussions ensemble, nous avons pris une seule fonction de hachage très forte pour avoir moins de chance qu'il y a 2 mots clés différents qui ont la même valeur de hachage. En réalité, sur l'ensemble 107 459 documents, il existe au plus un document pour chaque filtre de Bloom.
	
	Dans le cadre de notre projet, un document est une adresse URL décrit par l'ensemble de mots clés, ces mots clés sont écrits en codage UTF-8, sont basés sur plusieurs langues et contiennent les caractères spéciales. Donc, pour chaque filtre de Bloom, nous avons crée le fichier qui contient seulement cette adresse URL. En utilisant encore une fois la fonction de hachage SHA 256 bits, elle nous rend le nom unique pour chaque document et les stocke sur le disque.
	
	Dans le cas le plus simple, pour ajouter un nouveau document, nous appliquons cette fonction de hachage pour chaque mot clé. En appliquant encore une fois cette fonction sur le filtre de Bloom généré dans le premier temps, nous avons le fichier qui contient ce document qui correspond avec ses mots clés. Ensuite, la recherche de document, facilement, on ré-applique cette fonction de hachage sur l'ensemble de mots clés pour trouver le filtre, à partir de ce filtre, on peut trouver le nom du fichier qui contient ce document. Mais, cette solution marche si et seulement si on a exactement tous les mots clés dans la description d'un document, sinon cela ne marche jamais. Avec le filtre de Bloom, on peut savoir si ces mots clés existent dans l'ensemble des mots clés d'un document. Donc, pour chercher les documents qui contiennent ces mots clés, il faut regarder tous les filtres qui contiennent le filtre de la requête. Mais le parcours séquentiel est très lent sur le grand nombre de documents. 
	
\section{Index}
	Nous avons utilisé l'index pour indexer les filtres. Nous avons divisé chaque filtre de 512 bits en 64 morceaux de 8 bits. Pour chaque morceau, nous avons pris 4 bits, donc, à la fin, nous avons un nouveau filtre de taille 256 bits, la taille de ce nouveau filtre est égale à la moitié de l'ancien filtre. On applique cette façon pour tous les filtres existants, si deux filtres de taille 512 bits qui génèrent le même filtre de taille 256 bits, ces deux filtres ont même index. Pour chaque index, on crée un fichier qui correspond avec cet index (\-nous utilisons la fonction SHA 256 aussi pour générer le nom de ce fichier), contient les filtres de taille 512 bits qui ont cet index. Après la création des index, on trouve le nombre des fichiers index sont beaucoup moins que celui des fichiers de document. On a $2^{256}$ valeurs possibles pour les index au lieu de $2^{512}$ valeurs différents avec le filtre de 512 bits.
	
	$2^{256}$ est un nombre très grand, mais heureusement, un très grand nombre d'index ne est pas distribué. Pour éviter la recherche inutile sur les index inexistants, nous avons utilisé un tableau qui contient tous les index occupés. Ce tableau se situe dans le fichier $VA\_file$. La recherche devient plus facile et plus rapide car on calcule le filtre de taille 256 bits à partir de celui de taille 512 bits, ensuite, on cherche dans le fichier $VA\_file$ les index qui contient l'index de la requête, grâce à l'ensemble des index trouvés, on peut trouver les fichiers qui correspondent avec ces index pour trouver les filtres de taille 512 bits qui contiennent notre filtre de 512 bits. Si oui, on trouve l'ensemble des documents qui contient la requête. On note le filtre de Bloom de taille $k$ $B^k$, le filtre de la requête de taille $k$ $B^{k}_{req}$.
	
	Le problème est que le fichier $VA\_file$ sera explosé s'il y a des milliers d'index. Dans ce cas, pour résoudre le problème et pour ne pas faire agrandir le nombre de fichier à gérer, nous utilisons un nombre limite d'index pour chaque niveau d'index. Ce nombre est fixé à 1024 index. Une fois, le nombre d'index stocké dans le $VA\_file$ dépasse ce seuil, l'application crée un nouveau niveau d'index. Ce nouveau d'index est basé sur l'index plus bas. Par exemple, un filtre de Bloom de taille 256 bits $B^{256}_1$ est l'index d'un filtre de Bloom de taille 512 bits $B^{512}_0$. Donc, pour chaque niveau $i$, le filtre créé doit satisfaire la formule suivant: $B^{\frac{512}{2^i}}_i$. Le système regarde le fichier $VA\_file$ pour trouver les index existants et les transforme en nouveau niveau d'index. Chaque nouveau d'index correspond avec un fichier qui contient les index de niveau plus bas qui ont le même nouveau d'index. Le système va refaire chaque fois que le seuil est dépassé.
	
	Est-ce que le niveau d'index est illimité? La réponse est non. Pour le filtre de Bloom que nous avons choisi 512 bits, nous avons maximum 6 niveaux, $B^{8}_6$. Du coup, la taille de filtre de Bloom au niveau le plus haut est de 8 bits. A ce niveau, on a au maximum 256 valeurs d'index possibles dans le fichier $VA\_file$, un nombre très petit par rapport au quantité de données. 
	
	La technique d'augmentation le niveau dynamique est très efficace si on a un nombre de données n'est pas important. Si on a 100 000 documents à ajouter, la création des fichiers nécessaires nous prend plusieurs heures pour les créer. Donc, si on connaît le nombre de données, on peut fixer combien de niveaux d'index nécessaire. Selon notre résultat sur un disque dur SSD, nous avons fixé 6 niveaux d'index, la création nous coûte seulement 10 minuites. Avec la curiosité, nous avons essayé de réaliser sur un disque dur 80Go utilisé l'interface SATA II, il prend plus de deux heures pour faire le même travail. Du coup, nous avons laissé à côté la technique de création dynamique, et fixé 6 niveaux d'index utilisés.	
	
\section{Recherche de données}
	Puisque l'on a fixé le nombre de niveau, on connaît la taille du filtre de Bloom contenu dans le fichier $VA\_file$, sinon on peut lire ce fichier pour trouver quel niveau où on est. D'abord, le système crée le filtre de Bloom de taille 512 bits $B^{512}_{req}$ pour la requête selon l'ensemble de mots clés fourni par l'utilisateur. A partir de ce filtre, le système calcul l'index de niveau le plus haut $B^{8}_{6_{req}}$ et lit le fichier $VA\_file$ pour trouver l'ensemble des index qui contiennent $B^{8}_{6_{req}}$. Une fois on a trouvé, le résultat est stocké dans un fichier $res_6$ qui correspond à ce niveau, ici c'est niveau 6. Ensuite, le système lit ce fichier de résultat pour trouver le nom des fichiers d'index à niveau 6 $B^{8}_{6}$, il accéde à ces fichiers et compare avec le filtre de la requête au niveau 5 $B^{16}_{5_{req}}$ avec les filtres trouvés. Car le fichier $VA\_file$ contient les index de niveau 6, chaque fichier qui correspond avec un index à niveau 6, contient les index de niveau 5, etc... Le résultat trouvé est stocké dans un fichier $res_5$. 
	
	Le système utilise la même façon en descendant vers le niveau 1. Le fichier $res_1$ contient les filtres de taille 256 bits $B^{256}_{1}$, en regardant les fichiers de $B^{256}_{1}$, on trouve les filtres de taille 512 bits $B^{512}_{0}$ et les compare avec le filtre $B^{512}_{req}$ de la requête, une fois que le filtre existant contient celui de la requête, on peut trouver facilement le nom du fichier qui contient le document cherché. Après la recherche, on trouve un ensemble de documents qui contient les mots clés de la requête. On ne peut éviter les faux positifs, on fait confiance à la puisance de fonction de hachage. Mais avec certitude, on a trouvé tous les documents dont la description contiennent la requête.

\chapter{Algorithme des fonctions}
\section{CREATE\_FILTER}
\begin{algorithme}
	Création d'un filtre de Bloom à partir d'un ensemble des descriptions
\end{algorithme}

\begin{flushleft}
	\begin{framed}
		\textbf{IN:} $\sum desc$\\
		\textbf{FUNCTION:} \textit{create\_filter($\sum desc$)}\\
		\textbf{OUT:} \textit{$B^{512}$}\\

		\noindent\rule{\linewidth}{0.5pt}

		\begin{tabbing}
			$x \leftarrow$ FIRST($\sum desc$)\\
			\textit{init($B^{512}$)}\\
			\textbf{while} \= $x \neq \emptyset$ \textbf{do}\\
					\> $i \leftarrow SHA\_256(x)$\\
					\> $j \leftarrow i\ mod\ 512$\\
					\> $B^{512}[j]\leftarrow 1$\\
					\> $x \leftarrow$ NEXT($\sum desc$)\\
			\textbf{return} $B^{512}$\\
	    	\end{tabbing}		
	\end{framed}
\end{flushleft}

\section{PUT}
\begin{algorithme}
	Ajout d'un filtre dans le système
\end{algorithme}

\begin{flushleft}
	\begin{framed}
		\textbf{IN:} filtre de Bloom de taille 512 bits $B^{512}$\\
		\textbf{FUNCTION:} \textit{put($B^{512}$)}\\
		\textbf{OUT:} \textit{$\emptyset$}\\

		\noindent\rule{\linewidth}{0.5pt}

		\begin{tabbing}
			$i \leftarrow$ MAX\_LEVEL\\
			$vector_i \leftarrow$ CREATE\_VECTOR($B^{512}$, \textit{i})\\
			\textbf{if }\= $vector_i \notin$ \textit{VA\_file} \textbf{then}\\
					\> \textit{VA\_file $\leftarrow$} ADD($vector_i$)\\
			\textbf{end}	\\	
			\textbf{for }\=$i = MAX\_LEVEL\ ..\ 1$ \textbf{do}\\
					\> \textbf{if }\= $i == 1$ \textbf{then}\\
					\> 	\> $vector_i \leftarrow$ CREATE\_VECTOR($B^{512}$, \textit{i})\\
					\>	\> CREATE\_FILE($vector_i,\ B^{512}$)\\
					\> \textbf{else}\\
					\>	\> $vector_i \leftarrow$ CREATE\_VECTOR($B^{512}$, \textit{i})\\
					\>	\> CREATE\_FILE($vector_i$, CREATE\_VECTOR($B^{512}$, \textit{i - 1}))\\
			\textbf{end}	\\	
			\textbf{return} $\emptyset$\\
	    	\end{tabbing}		
	\end{framed}
\end{flushleft}

\section{SEARCH}
\begin{algorithme}
	Recherche d'un document à partir d'un filtre de Bloom
\end{algorithme}

\begin{flushleft}
	\begin{framed}
		\textbf{IN:} filtre de Bloom de taille 512 bits $B^{512}$\\
		\textbf{FUNCTION:} \textit{search($B^{512}$)}\\
		\textbf{OUT:} \textit{$\sum doc$}\\

		\noindent\rule{\linewidth}{0.5pt}

		\begin{tabbing}
			$i \leftarrow$ MAX\_LEVEL\\
			$vector_i \leftarrow$ CREATE\_VECTOR($B^{512}$, \textit{i})\\
			$x \leftarrow$ FIRST(\textit{VA\_file})\\
			$tmp \leftarrow$ CREATE\_FILE(\textit{i})\\
			\textbf{while }\=$x \neq \emptyset $ \textbf{do}\\
					\> \textbf{if}\= {then}\\
						\>\> 
					\> \textbf{end}\\
					\> $x \leftarrow$ NEXT(\textit{VA\_file})\\
			\textbf{end}\\
			\textbf{if }\= $vector_i \notin$ \textit{VA\_file} \textbf{then}\\
					\> \textbf{return }$\emptyset$\\
			\textbf{end}	\\
			\textbf{for }\=$i = MAX\_LEVEL\ ..\ 2$ \textbf{do}\\
					\> \\
			\textbf{end}	\\	
			\textbf{return} $\sum doc$\\
	    	\end{tabbing}		
	\end{framed}
\end{flushleft}









