\chapter{Réalisation du travail}
\section{Notre solution}
	Nous avons choisi le filtre de Bloom de taille fixe de 512 bits. A partir des descriptions en entrée, ce programme transforme chaque mot clé en 1 bit avec la position précise dans notre filtre. Nous avons utilisé une seul fonction de hachage comme SHA 256 bits, cette fonction encode le mot clé en une chaine hexadécimale de 256 bits. Avec un simple calcul, le filtre est bien rempli. Nous avons choisi seulement une fonction de hachage car si on utilise plus de 2 fonctions, avec un seul mot, elle génère 2 bits différents, donc, si on a 200 mots clés, ce filtre devient être tout rempli par 1. Ce problème nous rend l'imposibité de réduire l'ensemble des données à recherche. Et pourquoi doit-on ne pas augmenter la taille de filtre? Mais quelle taille suffit-il pour 200 descriptions si on a 3 fonctions de hachage? Après plusieurs tests et discussions ensemble, nous avons pris une seule fonction de hachage très forte pour avoir moins de chance qu'il y a 2 mots clés différents qui ont la même valeur de hachage. En réalité, sur l'ensemble 107 459 documents, il existe au plus un document pour chaque filtre de Bloom.
	
	Dans le cadre de notre projet, un document est une adresse URL décrit par l'ensemble de mots clés, ces mots clés sont écrits en codage UTF-8, sont basés sur plusieurs langues et contiennent les caractères spéciales. Donc, pour chaque filtre de Bloom, nous avons crée le fichier qui contient seulement cette adresse URL. En utilisant encore une fois la fonction de hachage SHA 256 bits, elle nous rend le nom unique pour chaque document et les stocke sur le disque.
	
	Dans le cas le plus simple, pour ajouter un nouveau document, nous appliquons cette fonction de hachage pour chaque mot clé. En appliquant encore une fois cette fonction sur le filtre de Bloom généré dans le premier temps, nous avons le fichier qui contient ce document qui correspond avec ses mots clés. Ensuite, la recherche de document, facilement, on ré-applique cette fonction de hachage sur l'ensemble de mots clés pour trouver le filtre, à partir de ce filtre, on peut trouver le nom du fichier qui contient ce document. Mais, cette solution marche si et seulement si on a exactement tous les mots clés dans la description d'un document, sinon cela ne marche jamais. Avec le filtre de Bloom, on peut savoir si ces mots clés existent dans l'ensemble des mots clés d'un document. Donc, pour chercher les documents qui contiennent ces mots clés, il faut regarder tous les filtres qui contiennent le filtre de la requête. Mais le parcours séquentiel est très lent sur le grand nombre de documents. 
	
\section{Index}
	Nous avons utilisé l'index pour indexer les filtres. Nous avons divisé chaque filtre de 512 bits en 64 morceaux de 8 bits. Pour chaque morceau, nous avons pris 4 bits, donc, à la fin, nous avons un nouveau filtre de taille 256 bits, la taille de ce nouveau filtre est égale à la moitié de l'ancien filtre. On applique cette façon pour tous les filtres existants, si deux filtres de taille 512 bits qui génèrent le même filtre de taille 256 bits, ces deux filtres ont même index. Pour chaque index, on crée un fichier qui correspond avec cet index (\-nous utilisons la fonction SHA 256 aussi pour générer le nom de ce fichier), contient les filtres de taille 512 bits qui ont cet index. Après la création des index, on trouve le nombre des fichiers index sont beaucoup moins que celui des fichiers de document. On a $2^{256}$ valeurs possibles pour les index au lieu de $2^{512}$ valeurs différents avec le filtre de 512 bits.
	
	$2^{256}$ est un nombre très grand, mais heureusement, un très grand nombre d'index ne sont pas distribué. Pour éviter la recherche inutile sur les index inexistants, nous avons utilisé un tableau qui contient tous les index occupés. Ce tableau se situe dans le fichier $VA\_file$. La recherche devient plus facile et plus rapid car on va calculer le filtre de taille 256 bits à partir de celui de taille 512 bits, ensuite, on cherche dans le fichier $VA\_file$ les index qui contient l'index de la requête, grâce à l'ensemble des index trouvés, on peut trouver les fichiers qui correspondent avec ces index pour trouver les filtres de taille 512 bits qui contiennent notre filtre de 512 bits. Si oui, on trouve l'ensemble des documents qui contient la requête.
	







